{"ast":null,"code":"/* Start of outer functions */\nfunction convertNumbertoByte(n) {\n  if (n < 0 || n > 255 || n % 1 !== 0) {\n    throw new Error(n + \" does not fit in a byte\");\n  }\n  return (\"000000000\" + n.toString(2)).substr(-8);\n}\nfunction convertNumbertoBigByte(n) {\n  if (n < 0 || n > 4294967296 || n % 1 !== 0) {\n    throw new Error(n + \" does not fit in a 4294967296\");\n  }\n  return (\"00000000000000000000000000000000\" + n.toString(2)).substr(-32);\n}\nfunction convertStringToBit(input) {\n  var output = \"\";\n  for (var i = 0; i < input.length; i++) {\n    output += (\"000000000\" + input[i].charCodeAt(0).toString(2)).substr(-8);\n  }\n  return output;\n}\nfunction convertByteToNumber(numBin) {\n  return parseInt(numBin, 2);\n}\nfunction changeLastSignificantBit(sourceByte, changeBit) {\n  if (sourceByte.length !== 8) throw new Error(\"This is not a valid byte!\");\n  if (changeBit === undefined) return sourceByte;\n  return sourceByte.substr(0, 7) + changeBit;\n}\nfunction binaryToWords(str) {\n  if (str.match(/[10]{8}/g)) {\n    var wordFromBinary = str.match(/([10]{8}|\\s+)/g).map(function (fromBinary) {\n      return String.fromCharCode(parseInt(fromBinary, 2));\n    }).join(\"\");\n    return wordFromBinary;\n  }\n}\n\n/* End of outer functions */\nexport default class Steganography {\n  constructor(context, img) {\n    this.rawImage = [];\n    this.currentImg = img;\n    this.imageContext = context;\n    console.log(\"Steganography created with raw data. Dimensions\", context);\n  }\n  CalculateByteSize() {\n    if (this.currentImg) {\n      return this.currentImg.width * this.currentImg.height * 3;\n    } else {\n      throw new Error(\"Function requires an image! Please check your constructor\");\n    }\n  }\n  HideDataInContext(content) {\n    this.CreateRawDataFromContext();\n    let data = this.EmbedTextInsideRawData(content);\n    return {\n      data: data,\n      image: this.currentImg\n    };\n  }\n  CreateRawDataFromContext() {\n    let rawData = [];\n    for (var c = 0; c < this.currentImg.width; c++) {\n      let singleColumn = [];\n      for (var r = 0; r < this.currentImg.height; r++) {\n        let imageData = this.imageContext.getImageData(c, r, 1, 1).data;\n        singleColumn.push(imageData);\n      }\n      rawData.push(singleColumn);\n    }\n    this.rawImage = rawData;\n  }\n  EmbedTextInsideRawData(content) {\n    if (!this.rawImage) throw new Error(\"Please call CreateRawDataFromContext() first!\");\n    if (content.length * 8 > this.CalculateByteSize()) {\n      throw new Error(\"Can't do the operation! Text is too big\");\n    }\n    content = btoa(unescape(encodeURIComponent(content)));\n    console.log(\"Content length\", content.length);\n    /*  We will reserve 4 bytes (32 bit) for message length */\n    let countForHeader = convertNumbertoBigByte(content.length);\n    let contentBinaryString = convertStringToBit(content);\n    contentBinaryString = countForHeader + contentBinaryString;\n    let ptr = 0;\n    for (var c = 0; c < this.rawImage.length; c++) {\n      for (var r = 0; r < this.rawImage[0].length; r++) {\n        for (let i = 0; i < 3; i++) {\n          let rD = this.rawImage[c][r][i];\n          this.rawImage[c][r][i] = convertByteToNumber(changeLastSignificantBit(convertNumbertoByte(rD), contentBinaryString[ptr]));\n          ptr++;\n        }\n        if (ptr >= contentBinaryString.length) {\n          return this.rawImage;\n        }\n      }\n    }\n  }\n  GetHiddenContent() {\n    let sizeHeader = \"\";\n    for (var c = 0; c < this.currentImg.width; c++) {\n      for (var r = 0; r < this.currentImg.height; r++) {\n        let imageData = this.imageContext.getImageData(c, r, 1, 1).data;\n        for (let i = 0; i < 3; i++) {\n          sizeHeader += convertNumbertoByte(imageData[i]).slice(-1);\n          if (sizeHeader.length === 32) break;\n        }\n        if (sizeHeader.length === 32) break;\n      }\n      if (sizeHeader.length === 32) break;\n    }\n    let messageCharCount = convertByteToNumber(sizeHeader);\n    let trc = -32; // Last 4 bytes\n    let contentInBits = \"\";\n    for (c = 0; c < this.currentImg.width; c++) {\n      for (r = 0; r < this.currentImg.height; r++) {\n        let imageData = this.imageContext.getImageData(c, r, 1, 1).data;\n        for (let i = 0; i < 3; i++) {\n          contentInBits += convertNumbertoByte(imageData[i]).slice(-1);\n          trc++;\n          if (trc >= messageCharCount * 8) break;\n        }\n        if (trc >= messageCharCount * 8) break;\n      }\n      if (trc >= messageCharCount * 8) break;\n    }\n    let content = decodeURIComponent(escape(atob(binaryToWords(contentInBits.substr(32)))));\n    return content;\n  }\n}","map":{"version":3,"names":["convertNumbertoByte","n","Error","toString","substr","convertNumbertoBigByte","convertStringToBit","input","output","i","length","charCodeAt","convertByteToNumber","numBin","parseInt","changeLastSignificantBit","sourceByte","changeBit","undefined","binaryToWords","str","match","wordFromBinary","map","fromBinary","String","fromCharCode","join","Steganography","constructor","context","img","rawImage","currentImg","imageContext","console","log","CalculateByteSize","width","height","HideDataInContext","content","CreateRawDataFromContext","data","EmbedTextInsideRawData","image","rawData","c","singleColumn","r","imageData","getImageData","push","btoa","unescape","encodeURIComponent","countForHeader","contentBinaryString","ptr","rD","GetHiddenContent","sizeHeader","slice","messageCharCount","trc","contentInBits","decodeURIComponent","escape","atob"],"sources":["C:/Users/vedan/OneDrive/Desktop/project/stegano/src/helpers/Steganography.js"],"sourcesContent":["/* Start of outer functions */\r\nfunction convertNumbertoByte(n) {\r\n  if (n < 0 || n > 255 || n % 1 !== 0) {\r\n    throw new Error(n + \" does not fit in a byte\");\r\n  }\r\n  return (\"000000000\" + n.toString(2)).substr(-8);\r\n}\r\n\r\nfunction convertNumbertoBigByte(n) {\r\n  if (n < 0 || n > 4294967296 || n % 1 !== 0) {\r\n    throw new Error(n + \" does not fit in a 4294967296\");\r\n  }\r\n  return (\"00000000000000000000000000000000\" + n.toString(2)).substr(-32);\r\n}\r\n\r\nfunction convertStringToBit(input) {\r\n  var output = \"\";\r\n  for (var i = 0; i < input.length; i++) {\r\n    output += (\"000000000\" + input[i].charCodeAt(0).toString(2)).substr(-8);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction convertByteToNumber(numBin) {\r\n  return parseInt(numBin, 2);\r\n}\r\n\r\nfunction changeLastSignificantBit(sourceByte, changeBit) {\r\n  if (sourceByte.length !== 8) throw new Error(\"This is not a valid byte!\");\r\n  if (changeBit === undefined) return sourceByte;\r\n  return sourceByte.substr(0, 7) + changeBit;\r\n}\r\n\r\nfunction binaryToWords(str) {\r\n  if (str.match(/[10]{8}/g)) {\r\n    var wordFromBinary = str\r\n      .match(/([10]{8}|\\s+)/g)\r\n      .map(function (fromBinary) {\r\n        return String.fromCharCode(parseInt(fromBinary, 2));\r\n      })\r\n      .join(\"\");\r\n    return wordFromBinary;\r\n  }\r\n}\r\n\r\n/* End of outer functions */\r\nexport default class Steganography {\r\n  rawImage = [];\r\n  constructor(context, img) {\r\n    this.currentImg = img;\r\n    this.imageContext = context;\r\n    console.log(\"Steganography created with raw data. Dimensions\", context);\r\n  }\r\n\r\n  CalculateByteSize() {\r\n    if (this.currentImg) {\r\n      return this.currentImg.width * this.currentImg.height * 3;\r\n    } else {\r\n      throw new Error(\r\n        \"Function requires an image! Please check your constructor\"\r\n      );\r\n    }\r\n  }\r\n\r\n  HideDataInContext(content) {\r\n    this.CreateRawDataFromContext();\r\n    let data = this.EmbedTextInsideRawData(content);\r\n    return { data: data, image: this.currentImg };\r\n  }\r\n\r\n  CreateRawDataFromContext() {\r\n    let rawData = [];\r\n    for (var c = 0; c < this.currentImg.width; c++) {\r\n      let singleColumn = [];\r\n      for (var r = 0; r < this.currentImg.height; r++) {\r\n        let imageData = this.imageContext.getImageData(c, r, 1, 1).data;\r\n        singleColumn.push(imageData);\r\n      }\r\n      rawData.push(singleColumn);\r\n    }\r\n    this.rawImage = rawData;\r\n  }\r\n\r\n  EmbedTextInsideRawData(content) {\r\n    if (!this.rawImage)\r\n      throw new Error(\"Please call CreateRawDataFromContext() first!\");\r\n    if (content.length * 8 > this.CalculateByteSize()) {\r\n      throw new Error(\"Can't do the operation! Text is too big\");\r\n    }\r\n    content = btoa(unescape(encodeURIComponent(content)));\r\n    console.log(\"Content length\", content.length);\r\n    /*  We will reserve 4 bytes (32 bit) for message length */\r\n    let countForHeader = convertNumbertoBigByte(content.length);\r\n    let contentBinaryString = convertStringToBit(content);\r\n    contentBinaryString = countForHeader + contentBinaryString;\r\n    let ptr = 0;\r\n    for (var c = 0; c < this.rawImage.length; c++) {\r\n      for (var r = 0; r < this.rawImage[0].length; r++) {\r\n        for (let i = 0; i < 3; i++) {\r\n          let rD = this.rawImage[c][r][i];\r\n          this.rawImage[c][r][i] = convertByteToNumber(\r\n            changeLastSignificantBit(\r\n              convertNumbertoByte(rD),\r\n              contentBinaryString[ptr]\r\n            )\r\n          );\r\n          ptr++;\r\n        }\r\n        if (ptr >= contentBinaryString.length) {\r\n          return this.rawImage;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  GetHiddenContent() {\r\n    let sizeHeader = \"\";\r\n    for (var c = 0; c < this.currentImg.width; c++) {\r\n      for (var r = 0; r < this.currentImg.height; r++) {\r\n        let imageData = this.imageContext.getImageData(c, r, 1, 1).data;\r\n        for (let i = 0; i < 3; i++) {\r\n          sizeHeader += convertNumbertoByte(imageData[i]).slice(-1);\r\n          if (sizeHeader.length === 32) break;\r\n        }\r\n        if (sizeHeader.length === 32) break;\r\n      }\r\n      if (sizeHeader.length === 32) break;\r\n    }\r\n\r\n    let messageCharCount = convertByteToNumber(sizeHeader);\r\n    let trc = -32; // Last 4 bytes\r\n    let contentInBits = \"\";\r\n    for (c = 0; c < this.currentImg.width; c++) {\r\n      for (r = 0; r < this.currentImg.height; r++) {\r\n        let imageData = this.imageContext.getImageData(c, r, 1, 1).data;\r\n        for (let i = 0; i < 3; i++) {\r\n          contentInBits += convertNumbertoByte(imageData[i]).slice(-1);\r\n          trc++;\r\n          if (trc >= messageCharCount * 8) break;\r\n        }\r\n        if (trc >= messageCharCount * 8) break;\r\n      }\r\n      if (trc >= messageCharCount * 8) break;\r\n    }\r\n    let content = decodeURIComponent(\r\n      escape(atob(binaryToWords(contentInBits.substr(32))))\r\n    );\r\n    return content;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}